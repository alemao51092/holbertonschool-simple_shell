#include "main.h"


char **tokenize(char *comand, int read)
{
    // Declarar variables
    char *copycom = NULL;
    char *token;
    char **argv;
    int count = 0, i = 0, j = 0;

    // Reservar memoria para una copia de la cadena de entrada
    copycom = malloc(sizeof(char) * read);
    if (copycom == NULL)
    {
        // Si falla la asignación, liberar memoria y devolver NULL
        free(copycom);
        return(NULL);
    }
    // Copiar la cadena de entrada en la nueva ubicación de memoria
    strcpy(copycom, comand);

    // Contar la cantidad de tokens en la cadena de entrada
    token = strtok (comand, " \n");
    while (token != NULL)
    {
        count++;
        token = strtok(NULL," \n");
    }
    count++;

    // Reservar memoria para el arreglo de cadenas de caracteres (argv)
    argv = malloc(sizeof(char *) * count);                                                                
    if (argv == NULL)
    {
        // Si falla la asignación, liberar memoria y devolver NULL
        free(argv);
        return(NULL);
    }

    // Extraer cada token de la cadena de entrada y almacenarlo en argv
    token = strtok(copycom, " \n");
    for(i = 0; token != NULL; i++)
    {
        // Reservar memoria para cada token y copiarlo en el arreglo argv
        argv[i] = malloc(sizeof(char) * strlen(token) + 1);
        if (argv[i] == NULL)
        {
            // Si falla la asignación, liberar memoria y devolver NULL
            for(j = 0; j < i; j++)
                free(argv[j]);
            free(argv);
            return(NULL);
        }
        strcpy(argv[i], token);
        // Extraer el siguiente token
        token = strtok(NULL, " \n");
    }

    // Terminar el arreglo argv con un puntero NULL
    argv[i] = NULL;

    // Liberar la memoria reservada para la copia de la cadena de entrada
    free(copycom);

    // Devolver el arreglo argv
    return(argv);
}






// Definir la función `getenv` que toma un puntero a una cadena de caracteres `var` como argumento y devuelve un puntero a una cadena de caracteres.
char *getenv(char *var)
{
    // Declarar un puntero doble `env` y asignarle el valor de la variable global `environ`, que es un puntero doble a una matriz de cadenas de caracteres que contiene las variables de entorno.
    char **env = environ;
    // Declarar variables enteras `x`, `y` y `con`, inicializar `x` a cero.
    int x = 0, y, con = 0;
    // Declarar un puntero `path` y asignarle el valor del puntero a `var`.
    char *path = NULL;
    path = var;

    // Si `var` es NULL o su primer elemento es un carácter nulo, devolver NULL.
    if (var == NULL || !var[x])
        return (NULL);

    // Declarar una variable `len` y asignarle el valor de la longitud de la cadena de caracteres `path`.
    int len = str_len(path);

    // Iterar sobre todas las variables de entorno.
    while (*(environ + x))
    {
        y = 0;
        // Iterar sobre cada caracter de la variable de entorno actual hasta encontrar un signo "=".
        while (*(*(env + x) + y) != '=')
        {
            // Si el caracter actual de la variable de entorno es igual al caracter correspondiente de `var`, aumentar `con`.
            if (*(*(env + x) + y) == var[y])
                con++;
            y++;
        }
        // Si la cantidad de caracteres coincidentes es igual a la longitud de `path`, se encontró la variable de entorno buscada.
        if (con == len)
        {
            // Avanzar `y` una posición para omitir el signo "=" y devolver el valor de la variable de entorno actual.
            y++;
            return (*(environ + x) + y);
        }
        // Avanzar al siguiente elemento en la matriz de variables de entorno y reiniciar `con`.
        x++;
        con = 0;
    }
    // Si no se encontró la variable de entorno, devolver 0.
    return (0);
}


char **get_comand(char **tokens)
{
	 char *ccopy; // se declara un puntero a char llamado "ccopy"
	 char **path = _path(); // se declara un puntero a puntero a char llamado "path" y se le asigna el valor de la función "_path"
	 char *function = NULL; // se declara un puntero a char llamado "function" y se le asigna el valor de NULL
	 int i = 0; // se declara un entero llamado "i" y se le asigna el valor de 0
	 struct stat buffer; // se declara una estructura de tipo "stat" llamada "buffer"

	// si el primer token es un archivo ejecutable, se devuelve el array "tokens"
	if (!stat(tokens[0], &buffer))
		return (tokens);

	// se recorre el array de rutas "path" para buscar el archivo ejecutable
	while (path[i])
	{
		ccopy = tokens[0]; // se copia el primer token en el puntero "ccopy"
		function = _calloc(_strlen(path[i]) + _strlen(ccopy) + 2, sizeof(char)); // se asigna a "function" un espacio de memoria dinámico suficiente para contener la ruta de la carpeta y el nombre del archivo ejecutable
		if (!function) // si no se pudo asignar memoria dinámica, se libera el array "path" y se muestra un mensaje de error
		{
			free(path);
			perror("Error");
			exit(EXIT_FAILURE);
		}
		strcpy(function, path[i]); // se copia la ruta de la carpeta del array "path" a la variable "function"
		strcat(function, "/"); // se agrega el caracter "/" a la variable "function"
		strcat(function, ccopy); // se agrega el nombre del archivo ejecutable a la variable "function"
		if (!stat(function, &buffer)) // si se encuentra el archivo ejecutable en la ruta "function", se asigna la ruta al primer token del array "tokens" y se devuelve el array "tokens"
		{
			tokens[0] = function;
			return (tokens);
		}
		i++; // se incrementa el contador de la ruta en el array "path"
		free(function), function = NULL; // se libera la memoria dinámica asignada a "function" y se asigna su valor a NULL
	}
	free(tokens); // si no se encuentra el archivo ejecutable, se libera la memoria dinámica asignada a "tokens"
	free_token(path); // se libera la memoria dinámica asignada al array "path"
	free(function); // se libera la memoria dinámica asignada a "function"
	return (0); // se devuelve NULL ya que no se encontró el archivo ejecutable
}


En resumen, las system calls son una forma de que los programas de usuario accedan a los servicios del sistema operativo y realicen tareas que no pueden ser realizadas por ellos mismos.

un proceso es una instancia de un programa en ejecucion, un proceso se crea cuando se inicia un programa


kernel En informática, un kernel es el núcleo o el corazón de un sistema operativo que se encarga de administrar los recursos del sistema, 
como la memoria, la CPU, los dispositivos de entrada y salida, entre otros.

la shell proporciona una intefaz y actua de intermediario entre el usuario y el sistema operativo ,
